#### 1.如何防止SQL注入
* 根据数据类型进行严格验证
* PHP的PDO可以进行参数化绑定

#### 2.mysql引擎
myisam和innodb
* innodb支持事务，还支持行级锁和外键
* innodb索引和文件放一起，是聚簇式设计
#### 3.mysql索引
从数据角度来看
* B+数索引
* 哈希索引
从逻辑角度看
* 主键索引
* 单列索引
* 多列索引，或者叫复合索引
#### 4.mysql索引优化
* 列越小越快
* 枚举类型代替varchar
* 避免null值
* 合理设置索引
* 考虑分表（如垂直分表）
#### 5.mysql索引失效
* like查询以%开头
* 在索引列上使用IS NULL操作
* 在索引列上使用not、!= 操作
* OR语句前后没有同时使用索引
#### 6.mysql死锁
两个或者多个事务执行过程中，因为互相等待对方持有的自愿，通常是表锁或者行锁，而陷入一直等待的状态。

举例：比如事务A先锁了表1，再锁表2；事务B先锁表2，再锁表1；最终事务A等待B的表2锁，事务B等待A的表1锁，形成了死锁
* mysql有死锁检测机制，一旦检测到会回滚代价最小的事务（往往是修改行数最少、执行时间最短的）

如何避免死锁？
* 所有事物操作资源时，都按固定的顺序来处理。比如先锁表1，再锁表2
* 事务中尽量晚加锁，早释放
* 如果业务允许，将批量更新拆分为单条更新
* 优先用innodb的行锁，而不是表锁
* 设置锁等待超时时间

#### 7.mysql脏读、幻读、不可重复读
* 脏读：a事务改完数据没提交，b事务读到a事务改完数据之后的数据，b事务读完之后，a事务回滚了。
* 不可重复度：a事务把数据读完拿去用，b事务刚好把数据改了并且提交，a事务读的数据就不准确了。
* 幻读：也是不可重复读的一种现象，例如a事务把id>3的数据name都改了，刚改完b事务插入了一条数据，那么a事务改完之后会发现有一条数据没有改成功。